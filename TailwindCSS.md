TailwindCSS (или Tailwind) - это фреймворк CSS, который предоставляет набор утилитарных классов для быстрого и удобного стилизации элементов на веб-страницах.

Использование TailwindCSS может значительно ускорить разработку интерфейсов, обеспечить большую гибкость в дизайне и уменьшить количество повторяющегося кода. Он особенно полезен в проектах, где требуется уникальный дизайн или быстрая прототипирование интерфейсов.

Использование утилитарных классов имеет преимущества перед написанием CSS-правил вручную:

1. **Готовые классы**: позволяют быстрее создавать пользовательские интерфейсы.
2. **Responsive дизайн**: упрощает работу с `@media` queries.
3. **Единообразие кода**: благодаря общим настройкам и стандартизированным классам.

Tailwind — не единственный utility-first фреймворк для CSS. Ранее самым популярным инструментом был Bootstrap. По сравнению с ним, Tailwind имеет следующие преимущества.

1. **Больше гибкости**: Tailwind дает больше контроля над дизайном, позволяя избегать эффекта «бутстрап-подобных» дизайнов.
2. **Tree-shaking для CSS**: конечный размер CSS обычно меньше по сравнению с полным набором стилей Bootstrap.
3. **Настройка**: TailwindCSS легко настраивается с помощью файла конфигурации, что позволяет адаптировать фреймворк под нужды проекта.

Самый известный недостаток TailwindCSS — требуется потратить время на то, чтобы привыкнуть и принять к его подходу. Поэтому я начну с обзора базовых концепций в разрезе их практического применения.

# Основные концепции

## Utility-first

Utility-first — это подход, основанный на утилитарных CSS-классах.

UF является следующим шагом в развитии подхода [Atomic CSS](https://css-tricks.com/lets-define-exactly-atomic-css/) (aka Functional CSS), когда мы оборачиваем CSS-правила в классы, каждое из которых выполняет одну конкретную функцию или применяют одно конкретное стилевое правило.

```css
.bg-blue {
  background-color: rgb(81, 191, 255);
}
.text-center {
  text-align: center;
}
.font-weight-400 {
  font-weight: 400;
}
```

Основное отличие между UF и Atomic CSS заключается в уровне гибкости и настройки. UF предлагает больше возможностей для настройки и комбинирования классов.

Например:
- `text-center` - выравнивает текст по центру.
- `bg-blue-500` - устанавливает синий фоновый цвет.
- `p-4` - применяет padding со всех сторон элемента.
- `tablet:rounded-lg` - делает углы элемента на планшетах закруглёнными.
В ручном CSS значения типа "500", "4", "tablet", "lg" пришлось бы расставлять вручную. В Atomic CSS — настраивать через CSS-переменные. Tailwind позволяет это всё сделать через удобный конфигурационный файл.

> [!QUESTION] Но зачем оборачивать правила, почему не использовать инлайновые стили (inline styles), указывая их напрямую в аттрибуте `style`?
> На то есть несколько причин:
> 1. **Ограничения** — утилитарные классы позволяют использовать переменные, ограничивая пространство вариантов. В инлайновых стили это невозможно
> 2. **Адаптивный дизайн** — инлайновые стили не поддерживают @media queries
> 3. **Hover, focus и другие состояния** — инлайновые стили не поддерживаю их стилизацию
## Modifiers

Модификаторы — это специальные префиксы или суффиксы, которые добавляются к утилитарным классам для изменения их поведения в определенных условиях. Эти модификаторы позволяют адаптировать стилизацию элементов в зависимости от различных факторов, таких как размер экрана, состояние элемента или даже темная тема.

```html
<button class="bg-violet-500 hover:bg-violet-600 active:bg-violet-700 focus:outline-none focus:ring focus:ring-violet-300">
	Save changes
</button>
```

Модификаторы используются, чтобы таргетировать:
1. **Состояние**:
    `hover`, `focus`, `active`, `visited`, `focus-within`, `focus-visible`, `open` (для dialog и details)
2. **Псевдоселекторы**:
    `first`, `last`, `even`, `odd`, `required`, `invalid`, `disabled`
3. **Псевдоэлементы**:
    `after`, `before`, `placeholder`, `file` (для input[type="file"]), `marker` (для списков), `selection` (для выделенного текста), `first-line` и `first-letter`, `backdrop` (для dialog)
4. **Медиа запросы**:
    `md`, `lg` (для размера экранов), `dark` (для цветовой схемы), `supports`, `motion-reduce`,  `contrast-more`, `portrait` и `landscape`
5. **HTML-Аттрибуты**:
   `aria-*` (для `aria-*="true"`), `data`, `rtl`

Дополнительно всегда можно создать [кастомные модификаторы](https://tailwindcss.com/docs/hover-focus-and-other-states#custom-modifiers)
### Групповые модификаторы

ГМ активируются когда псевдокласс устанавливается у другого элемента. Они бывают двух типов: группы предка с классом `group` и группы сиблингов с классом `peer`.

#### Группа предка

```html
<a
	href="#"
	class="group hover:bg-sky-500 hover:ring-sky-500">
	<div class="flex items-center space-x-3">
		<svg class="stroke-sky-500 group-hover:stroke-white"></svg> 
		<h3 class="text-slate-900 group-hover:text-white ">New project</h3>
	</div>
	<p class="text-slate-500 group-hover:text-white">Create a new project from a variety of starting templates.</p>
</a>
```

В этом примере, когда на элемент a.group будет наведена мышь, сработают не только модификаторы у него, но и у его потомков:
- класс `stroke-shite` применится к svg
- класс `text-white` применится h3 и p

#### Группа сиблинга

Сиблинг — это элемент, расположенный на том же уровне вложенности.

Синтаксис аналогичен группе предка, только теперь мы используем класс `peer`.

> [!important] Важно, чтобы класс `peer` был расположен до элементов с его модификаторами. Если в UI элемент с классом `peer` расположен ниже, можно использовать хак с абсолютным позиционированием, как в [этом видео](https://youtu.be/nJzKi6oIvBA?si=o0q14_6kSBCP6ux0)
#### Вложенные группы

Можно использовать несколько вложенных групп, идентифицируя их с помощью имён: давая классы родителям `group/[имя]` и потокам `group-[модификатор]/[имя]`:

```html
<li class="group/item hover:bg-slate-100">
	<a class="group/edit invisible hover:bg-slate-200 group-hover/item:visible">
		<span class="group-hover/edit:text-gray-700">
			Call
		</span>
		<svg class="group-hover/edit:translate-x-0.5 group-hover/edit:text-slate-500"></svg>
	</a>
</li>
```

Обрати внимание на использование двух групп `group/edit` и `group/item`

## Responsive design

Благодаря модификаторам, в Tailwind каждый класс может быть применён к конкретному брейкпоинту.

В Tailwind есть брейкпоинты по умолчанию:

|Модификатор-префикс|Минимальная ширина|Аналог в классическом CSS|
|---|---|---|
|`sm`|640px|`@media (min-width: 640px) { ... }`|
|`md`|768px|`@media (min-width: 768px) { ... }`|
|`lg`|1024px|`@media (min-width: 1024px) { ... }`|
|`xl`|1280px|`@media (min-width: 1280px) { ... }`|
|`2xl`|1536px|`@media (min-width: 1536px) { ... }`|

Ширина менее 640px используется по умолчанию — это соответствует подходу Mobile-first.

> *Mobile-first — это подход в веб-дизайне, при котором за отправную точку берётся версия для мобильных устройств, а затем расширяется для более крупных экранов.*

Если нужно ограничить диапазон размеров экранов, в которых используется класс, модификаторы размера экрана можно комбинировать:

```html
<img class="md:flex"> <!--Применяется на md и выше-->
<img class="md:max-lg:flex"> <!--Применяется от md до xl-->
```

### Настройка брейкпоинтов

Настройка иных значений брейкпоинтов делается в файле конфигурации tailwind.config.js:

```js
/** @type {import('tailwindcss').Config} */
module.exports = {
	theme: {
		screens: {
			'tablet': '640px', // аналогично @media (min-width: 640px) { ... }
			'laptop': '1024px',
			'desktop': '1280px',
		},
	},
}
```

## Тёмная тема

### Способ 1 — Автоматический
Tailwind поддерживает тёмную тему из коробки. Она работает автоматически благодаря свойству `prefers-color-scheme`, через которое ОС передаёт в браузер сайтам системную настройку `light` или `dark`.

Чтобы настроить тёмную тему, достаточно указать модификатор `dark`:
```html
<p class="text-slate-500 dark:text-slate-400 text-sm">Lorem Ipsum</p>
```

### Способ 2 — Вручную
Чтобы добавить переключение тем вручную, необходимо использовать механику класса на корневом элементе:
1. Делаем переключатель, который добавляет/убирает CSS-класс темы на html/body
2. Указываем название класса в файле конфигурации tailwind.config.js:
```js
/** @type {import('tailwindcss').Config} */
module.exports = {
	darkMode: 'class',
	... 
}
```

### Способ 3 — Комбинированный
Стратегия класса может быть использована для 

С помощью JavaScript и Window.matchMedia() API можно использовать по умолчанию настройку ОС, дав пользователю возможность переключать систему:

```js
// Считываем настройки ОС при загрузке страницы и сохраняем:
if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
	document.documentElement.classList.add('dark')
} else {
	document.documentElement.classList.remove('dark')
}

// Когда пользователь устанавливает тему:
localStorage.theme = toggler.value

// Когда пользователь устанавливает соответствовать настройкам ОС:
localStorage.removeItem('theme')
```

# Переиспользование стилей

Подход Utility-First Однако, использование утилитарных классов ставит в тупик, когда одинаковый набор классов используется на разных элементах:

```html
<div class="mt-3 flex">
	<img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="1.jpg"/>
	<img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="2.jpg"/>
	<img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="3.jpg"/>
	<img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="4.jpg"/>
</div>
```

> [!NOTE] Стоит упомянуть, что до определённого уровня проблему достаточно решить мульти-курсором, который поддерживает большинство IDE (например, [VS Code](https://code.visualstudio.com/docs/editor/codebasics#_multiple-selections-multicursor))

**Как это оптимизировать?**

- Использовать циклы (loop, map, etc.) — на уровне JS-фреймворка
- Создать UI-компонент с пропсами — на уровне JS-фреймворка
- Использовать директивы @layer и @apply — на уровне TailwindCSS

Поговорим о последнем способе.

## Директива @layer

`@layer` — это директива в TailwindCSS, которая используется для организации кастомного CSS в упорядоченные "слои". В Tailwind есть три основных слоя:

- `base` — используется для стилизации элементов по умолчанию, без использования классов. В него обычно включаются сбросы стилей или базовые стили для типографики.
- `components` — предназначен для определения стилей конкретных компонентов (кнопок, карточек, форм).
- `utilities` — модификатора, которые могут быть применены к различным элементам

Пример:
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
	h1 {
		@apply text-2xl;
	}
}

@layer components {
	.btn-blue {
		@apply bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded;
	}
}

@layer utilities {
	.filter-none {
		filter: none;
	}
	.filter-grayscale {
		filter: grayscale(100%);
	}
}
```

**Почему это Важно?**

1. **Правильный Порядок**: `@layer` гарантирует, что  пользовательский CSS будет вставлен в правильном порядке в итоговый CSS файл. Следовательно, стили применятся с нужным приоритетом
2. **Избегание Конфликтов**: Это помогает избежать конфликтов стилей
3. **Оптимизация Производительности**: Tailwind оптимизирует стили, если они организованы в `@layer`

Классы, включённые в `@layer`, доступны для использования с модификаторами, как обычные утилитарные класс.
## Директива @apply

`@apply` позволяет использовать утилитарные классы Tailwind внутри обычных CSS-правил. Это полезно, когда нужно скомбинировать несколько утилитарных классов Tailwind и применять их как единый класс.

```css
.btn {
  @apply bg-blue-500 text-white rounded;
}
```

Теперь у нас есть класс `.btn` для любой кнопки, и она автоматически получит все эти стили.

### Особенность использования !important

Если в правилах класса .foo было `!important`, то в классе .bar, которое будет включать `@apply foo;`, оно будет убрано.

Если `!important` всё же необходим, его следует вставить в конце строки включения — он применится ко всем стилям применённых классов:

```css
/* Input */
.btn {
	@apply font-bold py-2 px-4 rounded !important;
}

/* Output */
.btn {
	font-weight: 700 !important;
	padding-top: .5rem !important;
	padding-bottom: .5rem !important;
	padding-right: 1rem !important;
	padding-left: 1rem !important;
	border-radius: .25rem !important;
}
```
### Использование в компонентном подходе

Во фреймворках с компонентным подходе у каждого компонента свой блок style. Попытка использовать в нём @apply выдаст ошибку — ведь плагин сборщика (например, PostCSS) обрабатывает стили каждого компонента отдельно.

**TODO: проверить, есть ли такая проблема вообще?**

Есть несколько способов обойти эти ограничение:

- Описать нужный класс с использованием @apply в глобальном CSS-файле
- Создать класс с @apply в отдельном файле и импортировать его в компонент
- Настроить PostCSS, чтобы он верно обрабатывал директиву @apply
# Внешние источники
Документация — https://tailwindcss.com/docs
Обзор истории подходов — https://www.freecodecamp.org/news/what-is-tailwind-css-a-beginners-guide/
Best practices — https://evilmartians.com/chronicles/5-best-practices-for-preventing-chaos-in-tailwind-css