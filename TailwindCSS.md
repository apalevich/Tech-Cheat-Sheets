TailwindCSS (или Tailwind) - это фреймворк CSS, который предоставляет набор утилитарных классов для быстрого и удобного стилизации элементов на веб-страницах.

Использование TailwindCSS может значительно ускорить разработку интерфейсов, обеспечить большую гибкость в дизайне и уменьшить количество повторяющегося кода. Он особенно полезен в проектах, где требуется уникальный дизайн или быстрая прототипирование интерфейсов.

Использование утилитарных классов имеет преимущества перед написанием CSS-правил вручную:

1. **Готовые классы**: позволяют быстрее создавать пользовательские интерфейсы.
2. **Responsive дизайн**: упрощает работу с `@media` queries.
3. **Единообразие кода**: благодаря общим настройкам и стандартизированным классам.

Tailwind — не единственный utility-first фреймворк для CSS. Ранее самым популярным инструментом был Bootstrap. По сравнению с ним, Tailwind имеет следующие преимущества.

1. **Больше гибкости**: Tailwind дает больше контроля над дизайном, позволяя избегать эффекта «бутстрап-подобных» дизайнов.
2. **Tree-shaking для CSS**: конечный размер CSS обычно меньше по сравнению с полным набором стилей Bootstrap.
3. **Настройка**: TailwindCSS легко настраивается с помощью файла конфигурации, что позволяет адаптировать фреймворк под нужды проекта.

Самый известный недостаток TailwindCSS — требуется потратить время на то, чтобы привыкнуть и принять к его подходу. Поэтому я начну с обзора базовых концепций в разрезе их практического применения.

# Основные концепции

## Utility-first

Utility-first — это подход, основанный на утилитарных CSS-классах.

UF является следующим шагом в развитии подхода [Atomic CSS](https://css-tricks.com/lets-define-exactly-atomic-css/) (aka Functional CSS), когда мы оборачиваем CSS-правила в классы, каждое из которых выполняет одну конкретную функцию или применяют одно конкретное стилевое правило.

```css
.bg-blue {
  background-color: rgb(81, 191, 255);
}
.text-center {
  text-align: center;
}
.font-weight-400 {
  font-weight: 400;
}
```

Основное отличие между UF и Atomic CSS заключается в уровне гибкости и настройки. UF предлагает больше возможностей для настройки и комбинирования классов.

Например:
- `text-center` - выравнивает текст по центру.
- `bg-blue-500` - устанавливает синий фоновый цвет.
- `p-4` - применяет padding со всех сторон элемента.
- `tablet:rounded-lg` - делает углы элемента на планшетах закруглёнными.
В ручном CSS значения типа "500", "4", "tablet", "lg" пришлось бы расставлять вручную. В Atomic CSS — настраивать через CSS-переменные. Tailwind позволяет это всё сделать через удобный конфигурационный файл.

> [!QUESTION] Но зачем оборачивать правила, почему не использовать инлайновые стили (inline styles), указывая их напрямую в аттрибуте `style`?
> На то есть несколько причин:
> 1. **Ограничения** — утилитарные классы позволяют использовать переменные, ограничивая пространство вариантов. В инлайновых стили это невозможно
> 2. **Адаптивный дизайн** — инлайновые стили не поддерживают @media queries
> 3. **Hover, focus и другие состояния** — инлайновые стили не поддерживаю их стилизацию

Однако, использование утилитарных классов ставит в тупик, когда одинаковый набор классов используется на различных элементов. Как удобно работать с ними?
- Использовать мультикурсор в IDE
- Использовать циклы на уровне фреймворка (for loop, etc.)
- Создать абстрацию ([принцип DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)) на уровне фреймворка — компонент UI с пропсами
- Использовать директивы Tailwind — @layer и @apply (менее рекомендовано)

## Modifiers

Модификаторы — это специальные префиксы или суффиксы, которые добавляются к утилитарным классам для изменения их поведения в определенных условиях. Эти модификаторы позволяют адаптировать стилизацию элементов в зависимости от различных факторов, таких как размер экрана, состояние элемента или даже темная тема.

```html
<button class="bg-violet-500 hover:bg-violet-600 active:bg-violet-700 focus:outline-none focus:ring focus:ring-violet-300">
	Save changes
</button>
```

Примеры модификаторов:
1. **Псевдоклассы Состояния**
    Соответствуют псевдоклассам `hover`, `focus`, `active`, `visited`, `focus-within`, `focus-visible`, `first`, `last`, `even`, `odd`, `required`, `invalid`, `disabled`
3. **Отзывчивые (Responsive) Модификаторы**:
    
    - Пример: `md:text-center`. Здесь `md:` является модификатором, который применяет стиль `text-center` только на экранах среднего размера (md) и больше.
2. 
3. **Темная Тема (Dark Mode)**:
    
    - Пример: `dark:text-white`. Модификатор `dark:` применяет стиль `text-white` когда активна темная тема.
4. 
5. **Фокусировка и Активные Состояния**:
    
    - Примеры: `focus:ring`, `active:bg-red-500`. Эти модификаторы применяют стили при фокусировке (`focus:`) или активации (`active:`) элемента.
5. **HTML-Аттрибуты**:
   `rtl:mr-3` — применяет отступ mr-3 к элементу, когда активен режим Right-To-Left

### Групповые модификаторы

ГМ активируются когда псевдокласс устанавливается у другого элемента. Они бывают двух типов: группы предка с классом `group` и группы сиблингов с классом `peer`.

#### Группа предка

```html
<a
	href="#"
	class="group hover:bg-sky-500 hover:ring-sky-500">
	<div class="flex items-center space-x-3">
		<svg class="stroke-sky-500 group-hover:stroke-white"></svg> 
		<h3 class="text-slate-900 group-hover:text-white ">New project</h3>
	</div>
	<p class="text-slate-500 group-hover:text-white">Create a new project from a variety of starting templates.</p>
</a>
```

В этом примере, когда на элемент a.group будет наведена мышь, сработают не только модификаторы у него, но и у его потомков:
- класс `stroke-shite` применится к svg
- класс `text-white` применится h3 и p

#### Группа сиблинга

Сиблинг — это элемент, расположенный на том же уровне вложенности.

Синтаксис аналогичен группе предка, только теперь мы используем класс `peer`.

> [!important] Важно, чтобы класс `peer` был расположен до элементов с его модификаторами. Если в UI элемент с классом `peer` расположен ниже, можно использовать хак с абсолютным позиционированием, как в [этом видео](https://youtu.be/nJzKi6oIvBA?si=o0q14_6kSBCP6ux0)
#### Вложенные группы

Можно использовать несколько вложенных групп, идентифицируя их с помощью имён: давая классы родителям `group/[имя]` и потокам `group-[модификатор]/[имя]`:

```html
<li class="group/item hover:bg-slate-100">
	<a class="group/edit invisible hover:bg-slate-200 group-hover/item:visible">
		<span class="group-hover/edit:text-gray-700">
			Call
		</span>
		<svg class="group-hover/edit:translate-x-0.5 group-hover/edit:text-slate-500"></svg>
	</a>
</li>
```

Обрати внимание на использование двух групп `group/edit` и `group/item`

# Внешние источники
Документация — https://tailwindcss.com/docs
Обзор истории подходов — https://www.freecodecamp.org/news/what-is-tailwind-css-a-beginners-guide/
Best practices — https://evilmartians.com/chronicles/5-best-practices-for-preventing-chaos-in-tailwind-css