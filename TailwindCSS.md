TailwindCSS (или Tailwind) - это фреймворк CSS, который предоставляет набор утилитарных классов для быстрого и удобного стилизации элементов на веб-страницах.

Использование TailwindCSS может значительно ускорить разработку интерфейсов, обеспечить большую гибкость в дизайне и уменьшить количество повторяющегося кода. Он особенно полезен в проектах, где требуется уникальный дизайн или быстрая прототипирование интерфейсов.

Использование утилитарных классов имеет преимущества перед написанием CSS-правил вручную:

1. **Готовые классы**: позволяют быстрее создавать пользовательские интерфейсы.
2. **Responsive дизайн**: упрощает работу с `@media` queries.
3. **Единообразие кода**: благодаря общим настройкам и стандартизированным классам.

Tailwind — не единственный utility-first фреймворк для CSS. Ранее самым популярным инструментом был Bootstrap. По сравнению с ним, Tailwind имеет следующие преимущества.

1. **Больше гибкости**: Tailwind дает больше контроля над дизайном, позволяя избегать эффекта «бутстрап-подобных» дизайнов.
2. **Tree-shaking для CSS**: конечный размер CSS обычно меньше по сравнению с полным набором стилей Bootstrap.
3. **Настройка**: TailwindCSS легко настраивается с помощью файла конфигурации, что позволяет адаптировать фреймворк под нужды проекта.

Самый известный недостаток TailwindCSS — требуется потратить время на то, чтобы привыкнуть и принять к его подходу. Поэтому я начну с обзора базовых концепций в разрезе их практического применения.

# Основные концепции

## Utility-first

Utility-first — это подход, основанный на утилитарных CSS-классах.

UF является следующим шагом в развитии подхода [Atomic CSS](https://css-tricks.com/lets-define-exactly-atomic-css/) (aka Functional CSS), когда мы оборачиваем CSS-правила в классы, каждое из которых выполняет одну конкретную функцию или применяют одно конкретное стилевое правило.

```css
.bg-blue {
  background-color: rgb(81, 191, 255);
}
.text-center {
  text-align: center;
}
.font-weight-400 {
  font-weight: 400;
}
```

Основное отличие между UF и Atomic CSS заключается в уровне гибкости и настройки. UF предлагает больше возможностей для настройки и комбинирования классов.

Например:
- `text-center` - выравнивает текст по центру.
- `bg-blue-500` - устанавливает синий фоновый цвет.
- `p-4` - применяет padding со всех сторон элемента.
- `tablet:rounded-lg` - делает углы элемента на планшетах закруглёнными.
В ручном CSS значения типа "500", "4", "tablet", "lg" пришлось бы расставлять вручную. В Atomic CSS — настраивать через CSS-переменные. Tailwind позволяет это всё сделать через удобный конфигурационный файл.

> [!QUESTION] Но зачем оборачивать правила, почему не использовать инлайновые стили (inline styles), указывая их напрямую в аттрибуте `style`? На то есть несколько причин:
> 1. **Ограничения** — утилитарные классы позволяют использовать переменные, ограничивая пространство вариантов. В инлайновых стилях это невозможно
> 2. **Адаптивный дизайн** — инлайновые стили не поддерживают @media queries
> 3. **Hover, focus и другие состояния** — инлайновые стили не поддерживаю их стилизацию
## Modifiers

Модификаторы — это специальные префиксы или суффиксы, которые добавляются к утилитарным классам для изменения их поведения в определенных условиях. Эти модификаторы позволяют адаптировать стилизацию элементов в зависимости от различных факторов, таких как размер экрана, состояние элемента или даже темная тема.

```html
<button class="bg-violet-500 hover:bg-violet-600 active:bg-violet-700 focus:outline-none focus:ring focus:ring-violet-300">
	Save changes
</button>
```

Модификаторы используются, чтобы таргетировать:
1. **Состояние**:
    `hover`, `focus`, `active`, `visited`, `focus-within`, `focus-visible`, `open` (для dialog и details)
2. **Псевдоселекторы**:
    `first`, `last`, `even`, `odd`, `required`, `invalid`, `disabled`
3. **Псевдоэлементы**:
    `after`, `before`, `placeholder`, `file` (для input[type="file"]), `marker` (для списков), `selection` (для выделенного текста), `first-line` и `first-letter`, `backdrop` (для dialog)
4. **Медиа запросы**:
    `md`, `lg` (для размера экранов), `dark` (для цветовой схемы), `supports`, `motion-reduce`,  `contrast-more`, `portrait` и `landscape`
5. **HTML-Аттрибуты**:
   `aria-*` (для `aria-*="true"`), `data`, `rtl`

Дополнительно всегда можно создать [кастомные модификаторы](https://tailwindcss.com/docs/hover-focus-and-other-states#custom-modifiers)
### Групповые модификаторы

ГМ активируются когда псевдокласс устанавливается у другого элемента. Они бывают двух типов: группы предка с классом `group` и группы сиблингов с классом `peer`.

#### Группа предка

```html
<a
	href="#"
	class="group hover:bg-sky-500 hover:ring-sky-500">
	<div class="flex items-center space-x-3">
		<svg class="stroke-sky-500 group-hover:stroke-white"></svg> 
		<h3 class="text-slate-900 group-hover:text-white ">New project</h3>
	</div>
	<p class="text-slate-500 group-hover:text-white">Create a new project from a variety of starting templates.</p>
</a>
```

В этом примере, когда на элемент a.group будет наведена мышь, сработают не только модификаторы у него, но и у его потомков:
- класс `stroke-shite` применится к svg
- класс `text-white` применится h3 и p

#### Группа сиблинга

Сиблинг — это элемент, расположенный на том же уровне вложенности.

Синтаксис аналогичен группе предка, только теперь мы используем класс `peer`.

> [!important] Важно, чтобы класс `peer` был расположен до элементов с его модификаторами. Если в UI элемент с классом `peer` расположен ниже, можно использовать хак с абсолютным позиционированием, как в [этом видео](https://youtu.be/nJzKi6oIvBA?si=o0q14_6kSBCP6ux0)
#### Вложенные группы

Можно использовать несколько вложенных групп, идентифицируя их с помощью имён: давая классы родителям `group/[имя]` и потокам `group-[модификатор]/[имя]`:

```html
<li class="group/item hover:bg-slate-100">
	<a class="group/edit invisible hover:bg-slate-200 group-hover/item:visible">
		<span class="group-hover/edit:text-gray-700">
			Call
		</span>
		<svg class="group-hover/edit:translate-x-0.5 group-hover/edit:text-slate-500"></svg>
	</a>
</li>
```

Обрати внимание на использование двух групп `group/edit` и `group/item`

## Responsive design

Благодаря модификаторам, в Tailwind каждый класс может быть применён к конкретному брейкпоинту.

В Tailwind есть брейкпоинты по умолчанию:

|Модификатор-префикс|Минимальная ширина|Аналог в классическом CSS|
|---|---|---|
|`sm`|640px|`@media (min-width: 640px) { ... }`|
|`md`|768px|`@media (min-width: 768px) { ... }`|
|`lg`|1024px|`@media (min-width: 1024px) { ... }`|
|`xl`|1280px|`@media (min-width: 1280px) { ... }`|
|`2xl`|1536px|`@media (min-width: 1536px) { ... }`|

Ширина менее 640px используется по умолчанию — это соответствует подходу Mobile-first.

> *Mobile-first — это подход в веб-дизайне, при котором за отправную точку берётся версия для мобильных устройств, а затем расширяется для более крупных экранов.*

Если нужно ограничить диапазон размеров экранов, в которых используется класс, модификаторы размера экрана можно комбинировать:

```html
<img class="md:flex"> <!--Применяется на md и выше-->
<img class="md:max-lg:flex"> <!--Применяется от md до xl-->
```

### Настройка брейкпоинтов

Настройка иных значений брейкпоинтов делается в файле конфигурации tailwind.config.js:

```js
/** @type {import('tailwindcss').Config} */
module.exports = {
	theme: {
		screens: {
			'tablet': '640px', // аналогично @media (min-width: 640px) { ... }
			'laptop': '1024px',
			'desktop': '1280px',
		},
	},
}
```

## Тёмная тема

### Способ 1 — Автоматический
Tailwind поддерживает тёмную тему из коробки. Она работает автоматически благодаря свойству `prefers-color-scheme`, через которое ОС передаёт в браузер сайтам системную настройку `light` или `dark`.

Чтобы настроить тёмную тему, достаточно указать модификатор `dark`:
```html
<p class="text-slate-500 dark:text-slate-400 text-sm">Lorem Ipsum</p>
```

### Способ 2 — Вручную
Чтобы добавить переключение тем вручную, необходимо использовать механику класса на корневом элементе:
1. Делаем переключатель, который добавляет/убирает CSS-класс темы на html/body
2. Указываем название класса в файле конфигурации tailwind.config.js:
```js
/** @type {import('tailwindcss').Config} */
module.exports = {
	darkMode: 'class',
	... 
}
```

### Способ 3 — Комбинированный
Стратегия класса может быть использована для 

С помощью JavaScript и Window.matchMedia() API можно использовать по умолчанию настройку ОС, дав пользователю возможность переключать систему:

```js
// Считываем настройки ОС при загрузке страницы и сохраняем:
if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
	document.documentElement.classList.add('dark')
} else {
	document.documentElement.classList.remove('dark')
}

// Когда пользователь устанавливает тему:
localStorage.theme = toggler.value

// Когда пользователь устанавливает соответствовать настройкам ОС:
localStorage.removeItem('theme')
```

## Переиспользование стилей

Подход Utility-First Однако, использование утилитарных классов ставит в тупик, когда одинаковый набор классов используется на разных элементах:

```html
<div class="mt-3 flex">
	<img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="1.jpg"/>
	<img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="2.jpg"/>
	<img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="3.jpg"/>
	<img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="4.jpg"/>
</div>
```

> [!NOTE] Стоит упомянуть, что до определённого уровня проблему достаточно решить мульти-курсором, который поддерживает большинство IDE (например, [VS Code](https://code.visualstudio.com/docs/editor/codebasics#_multiple-selections-multicursor))

**Как это оптимизировать?**

- Использовать циклы (loop, map, etc.) — на уровне JS-фреймворка
- Создать UI-компонент с пропсами — на уровне JS-фреймворка
- Использовать директивы @layer и @apply — на уровне TailwindCSS

Поговорим о последнем способе.

### Директива @layer

`@layer` — это директива в TailwindCSS, которая используется для организации кастомного CSS в упорядоченные "слои". В Tailwind есть три основных слоя:

- `base` — используется для стилизации элементов по умолчанию, без использования классов. В него обычно включаются сбросы стилей или базовые стили для типографики.
- `components` — предназначен для определения стилей конкретных компонентов (кнопок, карточек, форм).
- `utilities` — модификатора, которые могут быть применены к различным элементам

Пример:
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
	h1 {
		@apply text-2xl;
	}
}

@layer components {
	.btn-blue {
		@apply bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded;
	}
}

@layer utilities {
	.filter-none {
		filter: none;
	}
	.filter-grayscale {
		filter: grayscale(100%);
	}
}
```

**Почему это Важно?**

1. **Правильный Порядок**: `@layer` гарантирует, что  пользовательский CSS будет вставлен в правильном порядке в итоговый CSS файл. Следовательно, стили применятся с нужным приоритетом
2. **Избегание Конфликтов**: Это помогает избежать конфликтов стилей
3. **Оптимизация Производительности**: Tailwind оптимизирует стили, если они организованы в `@layer`.

> [!hint] Tailwind анализирует использование CSS и убирает те правила и классы, которые не используются. Если необходимо включить правила без использования в проекте, необходимо описать его напрямую (без `@layer`) и до строки `@tailwind utilities`

Классы, включённые в `@layer`, доступны для использования с модификаторами, как обычные утилитарные класс.
### Директива @apply

`@apply` позволяет использовать утилитарные классы Tailwind внутри обычных CSS-правил. Это полезно, когда нужно скомбинировать несколько утилитарных классов Tailwind и применять их как единый класс.

```css
.btn {
  @apply bg-blue-500 text-white rounded;
}
```

Теперь у нас есть класс `.btn` для любой кнопки, и она автоматически получит все эти стили.

#### Особенность использования !important

Если в правилах класса .foo было `!important`, то в классе .bar, которое будет включать `@apply foo;`, оно будет убрано.

Если `!important` всё же необходим, его следует вставить в конце строки включения — он применится ко всем стилям применённых классов:

```css
/* Input */
.btn {
	@apply font-bold py-2 px-4 rounded !important;
}

/* Output */
.btn {
	font-weight: 700 !important;
	padding-top: .5rem !important;
	padding-bottom: .5rem !important;
	padding-right: 1rem !important;
	padding-left: 1rem !important;
	border-radius: .25rem !important;
}
```
#### Использование в компонентных фреймворках
Во фреймворках с компонентами у каждого компонента свой блок style. Попытка использовать в нём @apply выдаст ошибку — ведь плагин сборщика (например, PostCSS) обрабатывает стили каждого компонента отдельно.

**TODO: проверить, есть ли такая проблема вообще?**

Есть несколько способов обойти эти ограничение:

- Описать нужный класс с использованием @apply в глобальном CSS-файле
- Создать класс с @apply в отдельном файле и импортировать его в компонент
- Настроить PostCSS, чтобы он верно обрабатывал директиву @apply

## Кастомизация

Основной способ кастомизации стилей — через объект `theme` в файле `tailwind.config.js`. Там допустимы следующие ключи:

| Ключ          | Описание                                               | Пример записи                        |
|---------------|--------------------------------------------------------|--------------------------------------|
| `screens`     | Объект с брейкпоинтами для адаптивного дизайна         | `'sm': '640px'`                      |
| `colors`      | Определяет цветовую палитру                             | `'blue': '#1DA1F2'`                  |
| `spacing`     | Значения для отступов и маржинов                       | `'4': '1rem'`                        |
| `borderRadius`| Радиусы скругления углов                               | `'lg': '0.5rem'`                     |
| `fontSize`    | Размеры шрифтов                                        | `'lg': ['1.125rem', '1.75rem']`      |
| `fontWeight`  | Веса шрифтов                                           | `'bold': '700'`                      |
| `lineHeight`  | Высоты строк                                           | `'tight': '1.25'`                    |
| `boxShadow`   | Значения для теней элементов                           | `'md': '0 4px 6px -1px rgba(0, 0, 0, 0.1)'` |
| `extend`      | Расширяет существующие значения с новыми настройками   | `colors: { 'custom-blue': '#003366' }` |

Это основные ключи. Допустимо создать новые ключи и значения в зависимости от потребностей проекта.
### Произвольные значения

В случае, когда нужно использовать произвольное значение, не укладывающееся в настроенную систему, можно использовать аналог стилей - значение в квадратных скобках:

```html
<div class="top-[117px]">
	<!-- аналогично style="top: 117px;" -->
</div>

<div class="lg:top-[344px]">
	<!-- но можно использовать с модификаторами! -->
</div>

<div class="bg-[--my-color]">
	<!-- CSS-переменные доступны без var() -->
</div>

<div class="[mask-type:luminance]">
	<!-- при необходимости можно поместить правило целиком -->
</div>

<div class="grid grid-cols-[1fr_500px_2fr]">
	<!-- если в значении нужен пробел, используй _ вместо него -->
</div>

<div class="before:content-['hello\_world']">
	<!-- если нужен именно символ _ , то его нужно экранировать -->
</div>

<div className={String.raw`before:content-['hello\_world']`}>
	<!-- Если это вызовет проблемы в JSX, используй метод String.raw() -->
</div>
```

В большинстве случаев Tailwind постарается угадать нужное свойство из его значения, но можно указывать свойство явно:
```html
<!-- Will generate a font-size utility -->
<div class="text-[length:var(--my-var)]">...</div>

<!-- Will generate a color utility -->
<div class="text-[color:var(--my-var)]">...</div>
```

### Плагины

Плагины добавляют новые утилиты, компоненты, варианты или даже конфигурационные опции. А ещё это возможность настроить стили в Tailwind с помощью JavaScript.
#### Установка плагинов
Добавить сторонний плагин можно в два шага:
1. Установка плагина через пакетный менеджер (напр. `npm install`)
2. Подключение плагина в tailwind.config.js:
```js
module.exports = {
  // ...
  plugins: [
    require('tailwindcss-example-plugin'),
    // другие плагины
  ],
}
```

Официальные плагины
#### Написание плагинов
Для создания плагина необходимо импортировать функцию `tailwind/plugin` и вызвать её, передав в качестве аргумента функцию. У этой функции единственный аргумент — это объект с функциями-хелперами:

- `addUtilities()` для регистрации новых статических утилитных стилей.
- `matchUtilities()` для регистрации новых динамических утилитных стилей.
- `addComponents()` для регистрации новых статических стилей компонентов.
- `matchComponents()` для регистрации новых динамических стилей компонентов.
- `addBase()` для регистрации новых базовых стилей.
- `addVariant()` для регистрации пользовательских статических вариантов.
- `matchVariant()` для регистрации пользовательских динамических вариантов.
- `theme()` для поиска значений в конфигурации темы пользователя.
- `config()` для поиска значений в конфигурации Tailwind пользователя.
- `corePlugins()` для проверки, включен ли основной плагин.
- `e()` для ручной экранизации строк, предназначенных для использования в именах классов.

Пример инициализации плагина в tailwind.config.js:
```js
const plugin = require('tailwindcss/plugin')

module.exports = {
	plugins: [
		plugin(({ addBase, addComponents, addUtilities, theme }) => { 
			addBase({
				'h1': {
					fontSize: theme('fontSize.2xl'),
				},
			});
			addComponents({
				'.card': {
					backgroundColor: theme('colors.white'),
					borderRadius: theme('borderRadius.lg'),
					padding: theme('spacing.6'),
					boxShadow: theme('boxShadow.xl'),
				}
			});
			addUtilities({
				'.content-auto': {
					contentVisibility: 'auto',
				}
			})
		})
	]
}
```
# Внешние источники
Документация — https://tailwindcss.com/docs
Обзор истории подходов — https://www.freecodecamp.org/news/what-is-tailwind-css-a-beginners-guide/
Best practices — https://evilmartians.com/chronicles/5-best-practices-for-preventing-chaos-in-tailwind-css